name: Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: messoj/cift-markets
  # Define service names as they appear in docker-compose
  API_SERVICE: api
  FRONTEND_SERVICE: frontend

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Log in to the Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for API
        id: meta-api
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api

      - name: Build and push API image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: Dockerfile.simple # Using the simple/prod Dockerfile for stability
          push: true
          tags: |
            ${{ steps.meta-api.outputs.tags }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:latest
          labels: ${{ steps.meta-api.outputs.labels }}
          build-args: |
            BUILDKIT_INLINE_CACHE=1

      - name: Extract metadata (tags, labels) for Frontend
        id: meta-frontend
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/frontend

      - name: Build and push Frontend image
        uses: docker/build-push-action@v4
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: |
            ${{ steps.meta-frontend.outputs.tags }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/frontend:latest
          labels: ${{ steps.meta-frontend.outputs.labels }}

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    
    steps:
      - name: Deploy to Azure VM
        uses: appleboy/ssh-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          USERNAME: ${{ github.actor }}
        with:
          host: ${{ secrets.AZURE_VM_IP }}
          username: ${{ secrets.AZURE_VM_USERNAME }}
          key: ${{ secrets.AZURE_VM_SSH_KEY }}
          envs: GITHUB_TOKEN,USERNAME
          script: |
            # Ensure Docker client API >= 1.44 (older API may refuse to pull images)
            api_ver=$(docker version --format '{{.Client.APIVersion}}' 2>/dev/null || echo "0")
            if [ "$api_ver" = "0" ]; then
              echo "Docker not found — installing Docker..."
              curl -fsSL https://get.docker.com -o get-docker.sh
              sudo sh get-docker.sh
              sudo usermod -aG docker $USER
              sudo systemctl restart docker || true
            else
              # Compare versions using sort -V: if api_ver < 1.44 then upgrade
              if [ "$(printf '%s\n' "$api_ver" "1.44" | sort -V | head -n1)" != "1.44" ]; then
                echo "Docker client API $api_ver is older than 1.44 — upgrading Docker..."
                curl -fsSL https://get.docker.com -o get-docker.sh
                sudo sh get-docker.sh
                sudo systemctl restart docker || true
              else
                echo "Docker API version $api_ver is sufficient."
              fi
            fi

            # Clone repo if not present
            if [ ! -d "$HOME/cift-markets" ]; then
                echo "Cloning repository..."
                git clone https://x-access-token:$GITHUB_TOKEN@github.com/MessoJ/cift-markets.git ~/cift-markets
            fi

            # Navigate to app directory
            cd ~/cift-markets
            
            # Pull latest code
            git pull origin main
            
            # Login to registry (using sudo to ensure socket access)
            echo $GITHUB_TOKEN | sudo docker login ghcr.io -u $USERNAME --password-stdin
            
            # Create .env file from secrets if needed (optional, but good practice)
            # echo "POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}" > .env
            
            # Pull latest images
            # Free up disk space: prune unused images, containers, builders and dangling volumes
            echo "Cleaning up Docker disk usage to free space..."
            sudo docker system prune -af || true
            sudo docker volume prune -f || true
            # Remove buildx builders to free builder state
            if docker buildx ls >/dev/null 2>&1; then
              for b in $(docker buildx ls --format '{{.Name}}' | awk '{print $1}'); do
                docker buildx rm "$b" || true
              done
            fi

            # Try pulling images again
            sudo docker compose pull api frontend
            
            # Restart services
            sudo docker compose up -d --remove-orphans
            
            # Prune old images to save space
            sudo docker image prune -f
